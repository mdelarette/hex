<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>HEX</title>
	
	<!-- https://stackoverflow.com/questions/1664785/resize-html5-canvas-to-fit-window -->
	<style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
			overflow: hidden; /*  Disable scrollbars */
			display: block;  /* No floating content on sides */
        }
    </style>
	
	
    <!-- <link rel="stylesheet" href="style.css"> -->
    <script src="tuile.js"></script>
    <script src="renderer.js"></script>
    <script src="deck.js"></script>	
    <script src="hammer.min.js"></script>
	
    <script src="main.ts"></script>
	
	<!-- https://www.html5canvastutorials.com/ -->
	<!-- https://www.html5rocks.com/en/tutorials/canvas/performance/ -->
	<!-- https://www.redblobgames.com/grids/hexagons/ -->
	
  </head>

<body id="root" style="margin:0px;">


<script>


<!-- var blueImage = new Image();		 -->
<!-- blueImage.src = './ocean.jpg'; -->
<!-- var brownImage = new Image();		 -->
<!-- brownImage.src = './herbe.jpg'; -->


let width = 0;
let height = 0;
let size = 0;

let bg_canvas;
let fg_canvas;
let bgContext;
let fgContext;

let patterns = {blue:'#7dd1ff', brown: '#a65a35'};

let playFieldWithCoordinates = [];

let tuile; 
let shuffledDeck = [];

let mousePos = null;



let neighborhood = [
	{q: +1, r: 0},	{q: +1, r: -1},	{q: 0, r: -1}, {q: -1, r: 0}, {q: -1, r: +1}, {q: 0, r: +1},
];



function computeSize(playField, height) {
	
	let minMax = { min: 0, max: 0};
	
	minMax = playField.reduce((accumulator, tuile) => {return { min: Math.min(accumulator.min, tuile.coordinates.r), max: Math.max(accumulator.max, tuile.coordinates.r)};}, minMax);
		
	let nb = minMax.max + (-minMax.min) + 1 + 2;

	<!-- let coef = 2 + (nb-1) * (1 + Math.sin(Math.PI/6)); -->
	let coef = 2 + (nb-1) * 1.5;
	return Math.floor(height/coef);
}


function getMousePos(canvas, evt) {
	var rect = canvas.getBoundingClientRect();
	return {
	  x: evt.clientX - rect.left,
	  y: evt.clientY - rect.top
	};
}



// the window.onload event will fire when everything is loaded, including images etc.
window.onload = () => {
	
	// On windows, initiate heigth and width.  And size of "Tuile" 
	
	width = window.innerWidth - 8;
	height = window.innerHeight - 8;
	
	
	let root = document.getElementById("root");
	
	bg_canvas = document.createElement("canvas");
	bg_canvas.width = width;
	bg_canvas.height = height;
	bg_canvas.style = "border:1px solid #000000; position: absolute; z-index: 0";
	
	root.appendChild(bg_canvas);
	
	fg_canvas = document.createElement("canvas");
	fg_canvas.width = width;
	fg_canvas.height = height;
	fg_canvas.style = "border:1px solid #000000; position: absolute; z-index: 1";
	
	root.appendChild(fg_canvas);
	
	
	bgContext = bg_canvas.getContext("2d");
	fgContext = fg_canvas.getContext("2d");


	<!-- patterns.blue = bgContext.createPattern(blueImage, 'repeat'); -->
	<!-- patterns.brown = bgContext.createPattern(brownImage, 'repeat'); -->
	



	console.log("tuiles", tuiles);


	let deck = tuiles.map(tuile => {
		let a = [];
		for(var i = 0; i<tuile.quantite; i++) {
			a.push(tuile.tuile.id);
		}
		return a;
	}).flat();


	shuffledDeck = shuffleArray(deck);

	console.log("shuffledDeck", shuffledDeck);

	tuile = tuiles.find(x => x.tuile.id === shuffledDeck[0]).tuile;


	let playField = [];
	let state = 'Playing';


	<!-- let index = 0; -->
	<!-- for(var q = -2; q < 3; q++) -->
	<!-- { -->
		<!-- for(var r = -2; r < 3; r++) -->
		<!-- { -->
			<!-- let id = shuffledDeck[index++];	 -->
			<!-- let tuile = tuiles.find(x => x.tuile.id === id).tuile; -->
			
			<!-- tuile = { -->
				<!-- ...tuile, -->
				<!-- coordinates: {q, r} -->
			<!-- }; -->
			<!-- playFieldWithCoordinates.push(tuile); -->
		<!-- } -->
	<!-- } -->
	<!-- console.log("playFieldWithCoordinates", playFieldWithCoordinates); -->

	size = computeSize(playFieldWithCoordinates, height);


	drawPlayFieldWithCoordinates(bgContext, playFieldWithCoordinates, size, patterns);




	fg_canvas.addEventListener('mousemove', function(evt) {
		mousePos = getMousePos(fg_canvas, evt);
		
		fgContext.clearRect(0,0, width, height);

		drawTuile(fgContext, mousePos.x, mousePos.y, size, tuile, patterns );
		
	}, false);


	fg_canvas.addEventListener('wheel', function(evt) {
		<!-- console.log('wheel', evt); -->
		<!-- console.log('wheel', evt.deltaY); -->
		evt.preventDefault();
		tuile = {
			...tuile,
			cotes: rotateArray(tuile.cotes, evt.deltaY > 0 ? -1 : 1)
		};
		
		fgContext.clearRect(0,0, 1024, 768);

		drawTuile(fgContext, mousePos.x, mousePos.y, size, tuile, patterns );
		
	}, false);


	fg_canvas.addEventListener('click', function(evt) {
		console.log('click', evt);
		evt.preventDefault();
		
		mousePos = getMousePos(fg_canvas, evt);
		
		var coordinates = {q: 0, r: 0};
		if(playFieldWithCoordinates.length !== 0){
			coordinates = pixel_to_pointy_hex({x: mousePos.x - width/2, y: mousePos.y - height/2}, size);
		}
		
		// Test that space is free
		let inoccupied = playFieldWithCoordinates.find(t => t.coordinates.q === coordinates.q && t.coordinates.r === coordinates.r) === undefined;		
		if(!inoccupied)
		{
			console.warn("Already something here : ", coordinates);
			return;
		}
		
		// Test that space is adjacent
		if(playFieldWithCoordinates.length !== 0){
			let counter = 0;
			let neighbor = false;
			do {
				let checkCoordinates = {q: coordinates.q + neighborhood[counter].q, r: coordinates.r + neighborhood[counter].r };
				neighbor = playFieldWithCoordinates.find(t => t.coordinates.q === checkCoordinates.q && t.coordinates.r === checkCoordinates.r) ;	
				counter++;
			} while (neighbor === undefined && (counter < neighborhood.length));
			if(!neighbor)
			{
				console.warn("No neighbor : ", coordinates);
				return;
			}
		}

		playFieldWithCoordinates = [...playFieldWithCoordinates, {...tuile, coordinates: coordinates}];
		
		if(shuffledDeck.length > 0)
		{
			shuffledDeck.shift();
			tuile = tuiles.find(x => x.tuile.id === shuffledDeck[0]).tuile;
		}
		else
		{
			state = 'Counting';
		}
		
		console.log('shuffledDeck', shuffledDeck);
		console.log('playFieldWithCoordinates', playFieldWithCoordinates);
		
		bgContext.clearRect(0,0, width, height);
		fgContext.clearRect(0,0, width, height);
		
		size = computeSize(playFieldWithCoordinates, height);

		drawPlayFieldWithCoordinates(bgContext, playFieldWithCoordinates, size, patterns);
		drawTuile(fgContext, mousePos.x, mousePos.y, size, tuile, patterns );
		
	}, false);

	
	
	
	
	
	var hammertime = new Hammer(window, null);
	<!-- hammertime.get('pinch').set({ enable: true }); -->
	<!-- hammertime.get('rotate').set({ enable: true }); -->

	
	hammertime.on('pan', function(ev) {
		console.log('pan', ev);
	});
	
	hammertime.on('pinch', function(ev) {
		console.log('pinch', ev);
	});
	
	hammertime.on('press', function(ev) {
		console.log('press', ev);
	});
	
	hammertime.on('rotate', function(ev) {
		console.log('rotate', ev);
	});
	
	<!-- hammertime.on('swipe', function(ev) { -->
		<!-- console.log('swipe', ev); -->
	<!-- }); -->
	
	<!-- hammertime.on('tap', function(ev) { -->
		<!-- console.log('tap', ev); -->
	<!-- }); -->
	
	
	
	
	
	
	
	
};

	  
<!-- drawTuile(myContext, 500, 100, 75) -->


<!-- drawTuile(myContext, 50*cosPiSur6, 50, 50); -->
<!-- drawTuile(myContext, 50*cosPiSur6+2*50*cosPiSur6, 50, 50); -->

<!-- drawTuile(myContext, 50*cosPiSur6+1*50*cosPiSur6, 50+50+50*sinPiSur6, 50, tuile1); -->
<!-- drawTuile(myContext, 50*cosPiSur6+3*50*cosPiSur6, 50+50+50*sinPiSur6, 50, tuile2); -->


<!-- let x = 50; -->
<!-- let y = 50; -->
<!-- let colonne = 0; -->
<!-- for(var i = 0; i< tuiles.length; i++ ) -->
<!-- {	 -->
	<!-- let tuile = tuiles[i].tuile; -->
	
	<!-- <!-- console.log("Tuile i", i, tuile); --> -->
	
	<!-- console.log("Tuile x,y", x, y, colonne ); -->
	
	<!-- drawTuile(myContext, x, y, 25, tuile); -->
	
	<!-- colonne = (colonne + 1) % 13; -->
	<!-- x= x+50; -->
	<!-- if(colonne === 0) -->
	<!-- { -->
	<!-- x = 50; -->
		<!-- y= y+50; -->
	<!-- } -->

<!-- } -->





      <!-- // save canvas image as data url (png format by default) -->
      <!-- var dataURL = myCanvas.toDataURL(); -->

      <!-- // set canvasImg image src to dataURL -->
      <!-- // so it can be saved as an image -->
      <!-- document.getElementById('myCanvas').src = dataURL; -->


window.onresize = () => {

	width = window.innerWidth - 8;
	height = window.innerHeight - 8;
	
	size = computeSize(playFieldWithCoordinates, height);
	
	bg_canvas.width = width;
	bg_canvas.height = height
	
	fg_canvas.width = width;
	fg_canvas.height = height
	
	drawPlayFieldWithCoordinates(bgContext, playFieldWithCoordinates, size, patterns);
}


// Key listener
document.addEventListener('keyup', (e) => {	
	// Canceling last round
	if(e.key === 'z' && e.ctrlKey && playFieldWithCoordinates.length > 0)
	{		
		tuile = playFieldWithCoordinates.pop();
		delete tuile.coordinates;
		
		shuffledDeck = [tuile.id, ...shuffledDeck];
		
		bgContext.clearRect(0,0, width, height);
		fgContext.clearRect(0,0, width, height);
		
		size = computeSize(playFieldWithCoordinates, height);
		drawPlayFieldWithCoordinates(bgContext, playFieldWithCoordinates, size, patterns);
		drawTuile(fgContext, mousePos.x, mousePos.y, size, tuile, patterns );
	}

});
// Note, if more keys check, consider using Mouse trap :  https://github.com/ccampbell/mousetrap


</script>

</body>
</html>
